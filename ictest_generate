#!/usr/bin/env python2

import math
import os
import random
import re
import subprocess
import sys
import uuid

class StateVector:
    STATE_WIDTHS = {
        "INST1" : 8,
        "INST2" : 8,
        "INST3" : 8,
        "INST4" : 8,
        "A"     : 8,
        "A'"    : 8,
        "F"     : 8,
        "F'"    : 8,
        "BC"    : 16,
        "B'C'"  : 16,
        "DE"    : 16,
        "D'E'"  : 16,
        "HL"    : 16,
        "H'L'"  : 16,
        "IX"    : 16,
        "IY"    : 16,
        "SP"    : 16
    }

    def __init__(self, states, bitvector):
        self.states = states
        self.bitvector = bitvector

    @classmethod
    def parse(cls, fmt):
        states = []
        bitvector = []

        for word in fmt.split(','):
            m = re.match('^([\w\']+):([0-9a-fA-FxX]+)(b|h)$', word.strip())
            if not m:
                err = "malformed state vector element: {0}".format(word)
                raise ValueError(err)

            state, value, base = m.groups()

            width = len(value) if base == 'b' else (len(value) * 4)
            if width != StateVector.STATE_WIDTHS[state]:
                err = "state '{0}' has wrong bit width".format(state)
                raise ValueError(err)

            states.append(state)

            if base == 'b':
                bitvector += [int(digit, 2) if digit != 'x' else 'x'
                              for digit in value]
            else:
                for digit in value:
                    if digit == 'x':
                        bitvector += ['x', 'x', 'x', 'x']
                    else:
                        nibble = '{0:04b}'.format(int(digit, 16))
                        bitvector += [int(b) for b in nibble]

        return cls(states, bitvector)

    def copy(self):
        return StateVector(list(self.states), list(self.bitvector))

    def randomize(self):
        self.bitvector = [
            b if b != 'x' else random.randint(0, 1) for b in self.bitvector]


def generate_test(test_no, state_vector, runsim):
    ASM_STATE_FMT = {
        "A"    : " LD A,{0:03X}H\n",
        "A'"   : " EX AF,AF'\n LD A,{0:03X}H\n EX AF,AF'\n",
        "BC"   : " LD BC,{0:05X}H\n",
        "B'C'" : " EXX\n LD BC,{0:05X}H\n EXX\n",
        "DE"   : " LD DE,{0:05X}H\n",
        "D'E'" : " EXX\n LD DE,{0:05X}H\n EXX\n",
        "HL"   : " LD HL,{0:05X}H\n",
        "H'L'" : " EXX\n LD HL,{0:05X}H\n EXX\n",
        "IX"   : " LD IX,{0:05X}H\n",
        "IY"   : " LD IY,{0:05X}H\n",
        "SP"   : " LD SP,{0:05X}H\n"
    }

    VUNIT_ELEMS = {
        "A"    : "z80_i.cpu_i.datapath_i.reg_accu_i.q",
        "A'"   : "z80_i.cpu_i.datapath_i.reg_accu_p_i.q",
        "F"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q",
        "F'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q",
        "BC"   : "z80_i.cpu_i.datapath_i.regfile_i.bc",
        "B'C'" : "z80_i.cpu_i.datapath_i.regfile_i.bc_p",
        "DE"   : "z80_i.cpu_i.datapath_i.regfile_i.de",
        "D'E'" : "z80_i.cpu_i.datapath_i.regfile_i.de_p",
        "HL"   : "z80_i.cpu_i.datapath_i.regfile_i.hl",
        "H'L'" : "z80_i.cpu_i.datapath_i.regfile_i.hl_p",
        "IX"   : "z80_i.cpu_i.datapath_i.regfile_i.ix",
        "IY"   : "z80_i.cpu_i.datapath_i.regfile_i.iy",
        "SP"   : "z80_i.cpu_i.datapath_i.sp = 16'h{0:04X};\n"
    }

    VUNIT_STATE_FMT = {
        "A"    : "{0} = 8'h{1:02X};\n",
        "A'"   : "{0} = 8'h{1:02X};\n",
        "F"    : "{0} = 8'h{1:02X};\n",
        "F'"   : "{0} = 8'h{1:02X};\n",
        "BC"   : "{0} = 16'h{1:04X};\n",
        "B'C'" : "{0} = 16'h{1:04X};\n",
        "DE"   : "{0} = 16'h{1:04X};\n",
        "D'E'" : "{0} = 16'h{1:04X};\n",
        "HL"   : "{0} = 16'h{1:04X};\n",
        "H'L'" : "{0} = 16'h{1:04X};\n",
        "IX"   : "{0} = 16'h{1:04X};\n",
        "IY"   : "{0} = 16'h{1:04X};\n",
        "SP"   : "{0} = 16'h{1:04X};\n"
    }

    VUNIT_EXPECT_FMT = {
        "A"    : "unit.assert_eq8(8'h{0:02X}, {1}, \"A ({2})\");\n",
        "A'"   : "unit.assert_eq8(8'h{0:02X}, {1}, \"A' ({2})\");\n",
        "F"    : "unit.assert_eq8(8'h{0:02X}, {1}, \"F ({2})\");\n",
        "F'"   : "unit.assert_eq8(8'h{0:02X}, {1}, \"F' ({2})\");\n",
        "BC"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"BC ({2})\");\n",
        "B'C'" : "unit.assert_eq16(16'h{0:04X}, {1}, \"B'C' ({2})\");\n",
        "DE"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"DE ({2})\");\n",
        "D'E'" : "unit.assert_eq16(16'h{0:04X}, {1}, \"D'E' ({2})\");\n",
        "HL"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"HL ({2})\");\n",
        "H'L'" : "unit.assert_eq16(16'h{0:04X}, {1}, \"H'L' ({2})\");\n",
        "IX"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"IX ({2})\");\n",
        "IY"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"IY ({2})\");\n",
        "SP"   : "unit.assert_eq16(16'h{0:04X}, {1}, \"SP ({2})\");\n"
    }

    # test identifier
    test_uuid = str(uuid.uuid4())[:8]

    # z80sim input
    init_asm = ['START:\n']
    init_flags = '0x00'
    init_flags_p = '0x00'

    test_ops = []

    # ncsim input
    test_heading_fmt = "// BEGIN TESTCASE #{0} {1}\n"
    test_heading = test_heading_fmt.format(test_no, test_uuid)

    test = [test_heading]
    progmem = [test_heading]

    offs = 0
    for state in state_vector.states:
        width = StateVector.STATE_WIDTHS[state]
        binstr = ''.join(map(str, state_vector.bitvector[offs:(offs + width)]))
        binvalue = int(binstr, 2)

        if state.startswith('INST'):
            test_ops.append(chr(binvalue))
            progmem.append('{0:02X}\n'.format(binvalue))
        else:
            vunit_state_fmt = VUNIT_STATE_FMT[state]
            vunit_state = vunit_state_fmt.format(VUNIT_ELEMS[state], binvalue)
            test.append(vunit_state)

            if state == 'F':
                init_flags = '{0:02X}'.format(binvalue)
            elif state == "F'":
                init_flags_p = '{0:02X}'.format(binvalue)
            else:
                init_asm.append(ASM_STATE_FMT[state].format(binvalue))

        offs += width

    init_asm.append(' HALT')

    # create reference simulation output
    asm_tmp = open('tmp.asm', 'w+')
    bin_tmp = open('tmp.bin', 'w+')
    devnull = open(os.devnull, 'w')

    try:
        # assemble bytecode
        asm_tmp.writelines(init_asm)
        asm_tmp.close()

        z80asm = subprocess.Popen(['z80asm', asm_tmp.name], stdout=devnull)
        z80asm.wait()

        # inject instruction bytes
        data = bin_tmp.read()
        instructions = [data[i:i+1] for i in range(len(data))]

        for op in test_ops:
            instructions.insert(-1, op)

        bin_tmp.seek(0)
        bin_tmp.write(b''.join(instructions))
        bin_tmp.close()

        z80sim = subprocess.Popen(
            [runsim, bin_tmp.name, init_flags, init_flags_p],
            stdout=subprocess.PIPE)

        z80sim.wait()

    finally:
        asm_tmp.close()
        bin_tmp.close()
        devnull.close()

        os.remove(asm_tmp.name)
        os.remove(bin_tmp.name)

    # parse simulation results
    simout = z80sim.stdout.read()
    regs, values = re.search(r'HALT.*\s+(.*)\s+(.*)\s+>>>', simout).groups()

    expected = {}
    regs = [r.strip() for r in regs.split()]
    values = [v.strip() for v in values.split()]

    for r, v in zip(regs, values):
        if r == 'SZHPNC':
            expected['F'] = int('{0}0{1}0{2}'.format(v[:2], v[2], v[3:]), 2)
        elif r == "A'F'":
            expected["A'"] = int(v[:2], 16)
            expected["F'"] = int(v[2:], 16)
        elif r in state_vector.states:
            expected[r] = int(v, 16)

    # add timeout loop to testbench code
    waitloop = [
        "#(CLKPERIOD);",
        "",
        "loop_counter = 5'b0;",
        "while (z80_i.cpu_i.controller_i.fsm_i.state != FSM_STATE_INSTR_FETCH1_1)",
        "begin",
        "    #(CLKPERIOD);",
        "    loop_counter = loop_counter + 1;",
        "    if (loop_counter == 5'b11111)",
        "        unit.fail(\"Instruction not terminating\");",
        "end"
    ]

    test.append('\n{0}\n\n'.format('\n'.join(waitloop)))

    # add assertions to testbench code
    for state in state_vector.states:
        if state.startswith('INST'):
            continue

        msg = "Testcase #{0} {1}".format(test_no, test_uuid)
        vunit_expect_fmt = VUNIT_EXPECT_FMT[state]
        vunit_expect = vunit_expect_fmt.format(expected[state],
                                               VUNIT_ELEMS[state], msg)
        test.append(vunit_expect)

    test.append('\n')

    return test, progmem


if __name__ == '__main__':
    MAXTESTS = 1024

    PROGMEM_SIZE = 4096
    DATAMEM_SIZE = 512

    ZEX_FILE = 'zex.txt'
    TESTCASE_FILE = 'testcase.v'
    PROGMEM_FILE = 'progmem.txt'
    DATAMEM_FILE = 'datamem.txt'
    DATAMEM_BIN_FILE = 'datamem.bin'
    RUNSIM_FILE = 'runsim.exp'

    # read test description
    with open(ZEX_FILE) as infile:
        zex = infile.read()

    # strip comments and trailing whitespace
    zex = re.sub(r'(?m)\s*(;.*)?$', '', zex)

    # remove empty lines
    zex = '\n'.join([line for line in zex.split('\n') if line])

    # parse components
    pattern = r'''
    ^
    name:\s+(.*)\s+
    desc:\s+(.*)\s+
    base:\s+(.*)\s+
    cycle:\s+(.*)
    $
    '''

    m = re.match(pattern, zex, re.VERBOSE)
    if not m:
        raise ValueError("malformatted test description file")

    name = m.group(1)
    desc = m.group(2)
    base = StateVector.parse(m.group(3))
    cycle = StateVector.parse(m.group(4))

    # state vector cycle positions
    cycle_pos = [i for i, b in enumerate(cycle.bitvector) if b == 1]
    cycles = list(range(2**len(cycle_pos)))

    if (len(cycles) > MAXTESTS):
        err = "trying to generate {0} tests (maximum is {1})"
        raise ValueError(err.format(len(cycles), MAXTESTS))

    # generate testcase files
    testcase_out = open(TESTCASE_FILE, 'w+')
    progmem_out = open(PROGMEM_FILE, 'w+')
    datamem_out = open(DATAMEM_FILE, 'w+')
    datamem_bin_out = open(DATAMEM_BIN_FILE, 'w+')
    runsim_out = open(RUNSIM_FILE, 'w+')

    os.chmod(RUNSIM_FILE, 500)

    # create random data memory
    datamem = []
    datamem_bin = [255, 0, 0]
    for addr in range(DATAMEM_SIZE):
        rand_val = random.randint(0, 255)

        datamem.append('@{0:04X} {1:02X}\n'.format(addr, rand_val))
        datamem_bin.append(rand_val)

    datamem_bin = bytes(bytearray(datamem_bin))

    try:
        # create z80 simulator expect file
        runsim_out.writelines([
            '#!/usr/bin/expect -f\n',
            '\n',
            'set prog_bin  [lindex $argv 0];\n',
            'set setflags  [lindex $argv 1];\n',
            'set setflagsp [lindex $argv 2];\n',
            '\n',
            'spawn z80sim\n',
            'expect ">>>"\n',
            'send "x f\\r"\n',
            'expect "F = "\n',
            'send "$setflags\\r"\n',
            'expect ">>>"\n',
            'send "x f\'\\r"\n',
            'expect "F\' = "\n',
            'send "$setflagsp\\r"\n',
            'expect ">>>"\n',
            'send "r $prog_bin,0\\r"\n',
            'expect ">>>"\n',
            'send "v 0,{0},{1}\r"\n'.format(DATAMEM_SIZE, PROGMEM_SIZE),
            'expect ">>>"\n',
            'send "r {0},0\\r"\n'.format(DATAMEM_BIN_FILE),
            'expect ">>>"\n',
            'send "g {0}\\r"\n'.format(DATAMEM_SIZE),
            'expect ">>>"\n',
            'send "quit\\r"'
        ])
        runsim_out.close()

        # fill data memory
        datamem_out.writelines(datamem)
        datamem_out.close()

        datamem_bin_out.write(datamem_bin)
        datamem_bin_out.close()

        # begin creating testcase file
        testcase_out.write('unit.start("{0} ({1})");\n\n'.format(name, desc))

        for test_no, cycle in enumerate(cycles):
            # display progress
            fmt = "\rgenerating test {0}/{1}"
            sys.stdout.write(fmt.format(test_no + 1, len(cycles)))
            sys.stdout.flush()

            # create state vector variant
            vect = base.copy()

            if cycle > 0:
                setbits = '{0:b}'.format(cycle).zfill(len(cycle_pos))
                for i, b in enumerate(setbits):
                    vect.bitvector[cycle_pos[i - 1]] = int(b)

            vect.randomize()

            # generate test and update files
            test, progmem = generate_test(test_no, vect, './' + RUNSIM_FILE)
            testcase_out.writelines(test)
            progmem_out.writelines(progmem)

        testcase_out.write('unit.finish("{0} ({1})");\n'.format(name, desc))

        sys.stdout.write('\n')

    finally:
        testcase_out.close()
        progmem_out.close()
        datamem_out.close()
        datamem_bin_out.close()
        runsim_out.close()

        os.remove(RUNSIM_FILE)
        os.remove(DATAMEM_BIN_FILE)
