#!/usr/bin/env python2

import math
import os
import random
import re
import subprocess
import sys
import uuid

# external programs
ASM = 'z80asm'
RUNSIM = 'ictest_runsim'

# limits
MAXTESTS = 2048
PROGMEM_SIZE = 8192
DATAMEM_SIZE = 8192

# output files
ZEX_FILE = 'zex.txt'
TESTCASE_FILE = 'testcase.v'
PROGMEM_FILE = 'progmem.txt'
DATAMEM_FILE = 'datamem.txt'

# temporary files
ASM_FILE = 'progmem.asm'
PROGMEM_BIN_FILE = 'progmem.bin'
DATAMEM_BIN_FILE = 'datamem.bin'

# bit widths
STATE_WIDTHS = {
    "INST1" : 8,
    "INST2" : 8,
    "INST3" : 8,
    "INST4" : 8,
    "A"     : 8,
    "A'"    : 8,
    "F"     : 8,
    "F'"    : 8,
    "BC"    : 16,
    "B'C'"  : 16,
    "DE"    : 16,
    "D'E'"  : 16,
    "HL"    : 16,
    "H'L'"  : 16,
    "IX"    : 16,
    "IY"    : 16,
    "SP"    : 16,
    "DUMMY" : 8
}

# program counter reset after voluntary jump
current_pc = 0

def parse_word(word, state):
    m = re.match('^([0-9a-fA-FxX]+)(b|h)$', word)
    if not m:
        raise ValueError("malformed word: {0}".format(word))

    value, base = m.groups()

    width = len(value) if base == 'b' else (len(value) * 4)
    if width != STATE_WIDTHS[state]:
        err = "state '{0}' has wrong bit width".format(state)
        raise ValueError(err)

    if base == 'b':
        return [int(digit, 2) if digit != 'x' else 'x'
                for digit in value]
    else:
        ret = []
        for digit in value:
            if digit == 'x':
                ret += ['x', 'x', 'x', 'x']
            else:
                ret += [int(b) for b in '{0:04b}'.format(int(digit, 16))]

        return ret

class StateVector:
    def __init__(self, states, bitvector):
        self.states = states
        self.bitvector = bitvector

    @classmethod
    def parse(cls, fmt):
        states = []
        bitvector = []

        for word in [w.strip() for w in fmt.split(',')]:
            m = re.match('^([\w\']+):([0-9a-fA-FxX]+(?:b|h))$', word)
            if not m:
                err = "malformed state vector element: {0}".format(word)
                raise ValueError(err)

            state, word = m.groups()
            if state not in STATE_WIDTHS:
               err = "unknown state in state vector: '{0}'".format(state)
               raise ValueError(err)

            states.append(state)
            bitvector += parse_word(word, state)

        return cls(states, bitvector)

    def copy(self):
        return StateVector(list(self.states), list(self.bitvector))

    def randomize(self):
        self.bitvector = [
            b if b != 'x' else random.randint(0, 1) for b in self.bitvector]


class SkipVector:
    def __init__(self, stateignore):
        self.stateignore = stateignore

    @classmethod
    def parse(cls, fmt):
        stateignore = {}

        for word in [w.strip() for w in fmt.split(',')]:
            word_fmt = '[0-9a-fA-FxX]+(?:b|h)'

            m = re.match('^(\w+):{{({0}(?:;{0})*)}}$'.format(word_fmt), word)
            if not m:
                 err = "malformed skip vector element: {0}".format(word)
                 raise ValueError(err)

            state, ignore = m.groups()
            if state not in STATE_WIDTHS:
                err = "unknown state in skip vector: '{0}'".format(state)
                raise ValueError(err)

            if state in stateignore:
                err = "duplicate state in skip vector: '{0}'".format(state)
                raise ValueError(err)

            stateignore[state] = []
            for word in [i.strip() for i in ignore.split(';')]:
                stateignore[state].append(parse_word(word, state))

        return SkipVector(stateignore)

    def check(self, vect):
        offs = 0
        for state in vect.states:
            if state not in self.stateignore:
                continue

            width = STATE_WIDTHS[state]
            value = vect.bitvector[offs:(offs + width)]

            for ignore in self.stateignore[state]:
                skip = True
                for v, i in zip(value, ignore):
                    if i == 'x':
                        continue

                    if v != i:
                        skip = False
                        break
                if skip:
                    return True

            offs += width

        return False


class MemCheck:
    MNEMONICS = {
        "(BC)" : ["id", "BC"],
        "(DE)" : ["id", "DE"],
        "(HL)" : ["id", "HL"],
        "(SP)" : ["id", "SP"],
        "(IX + INST3)" : ["+", "IX", "INST3"],
        "(IY + INST3)" : ["+", "IY", "INST3"]
    }

    def __init__(self, states, pre, addrs=None, expected=None):
        self.states = states
        self.pre = pre
        self.addrs = addrs or []
        self.expected = expected or []

    @classmethod
    def parse(cls, fmt):
        states = []
        pre = {}
        for mnemonic in [m.strip() for m in fmt.split(',')]:
            if mnemonic not in MemCheck.MNEMONICS:
                err = "malformed memory check element: {0}".format(mnemonic)
                raise ValueError(err)

            states.append(mnemonic)

            for m in MemCheck.MNEMONICS[mnemonic][1:]:
                pre[m] = None

        return MemCheck(states, pre)

    def clear(self):
        for key in self.pre:
            self.pre[key] = None

        self.addrs = []
        self.expected = []


def generate_test(test_no, state_vector, options):
    ASM_STATE_FMT = {
        "A"    : " LD A,{0:03X}H\n",
        "A'"   : " EX AF,AF'\n LD A,{0:03X}H\n EX AF,AF'\n",
        "BC"   : " LD BC,{0:05X}H\n",
        "B'C'" : " EXX\n LD BC,{0:05X}H\n EXX\n",
        "DE"   : " LD DE,{0:05X}H\n",
        "D'E'" : " EXX\n LD DE,{0:05X}H\n EXX\n",
        "HL"   : " LD HL,{0:05X}H\n",
        "H'L'" : " EXX\n LD HL,{0:05X}H\n EXX\n",
        "IX"   : " LD IX,{0:05X}H\n",
        "IY"   : " LD IY,{0:05X}H\n",
        "SP"   : " LD SP,{0:05X}H\n"
    }

    VUNIT_ELEMS = {
        "A"    : "z80_i.cpu_i.datapath_i.reg_accu_i.q",
        "A'"   : "z80_i.cpu_i.datapath_i.reg_accu_p_i.q",
        "F"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q",
        "F'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q",
        "S"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_S]",
        "S'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_S]",
        "Z"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_Z]",
        "Z'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_Z]",
        "H"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_H]",
        "H'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_H]",
        "PV"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_PV]",
        "PV'"  : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_PV]",
        "N"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_N]",
        "N'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_N]",
        "C"    : "z80_i.cpu_i.datapath_i.reg_alu_flags_i.q[ALU_FLAG_C]",
        "C'"   : "z80_i.cpu_i.datapath_i.reg_alu_flags_p_i.q[ALU_FLAG_C]",
        "BC"   : "z80_i.cpu_i.datapath_i.regfile_i.bc",
        "B'C'" : "z80_i.cpu_i.datapath_i.regfile_i.bc_p",
        "DE"   : "z80_i.cpu_i.datapath_i.regfile_i.de",
        "D'E'" : "z80_i.cpu_i.datapath_i.regfile_i.de_p",
        "HL"   : "z80_i.cpu_i.datapath_i.regfile_i.hl",
        "H'L'" : "z80_i.cpu_i.datapath_i.regfile_i.hl_p",
        "IX"   : "z80_i.cpu_i.datapath_i.regfile_i.ix",
        "IY"   : "z80_i.cpu_i.datapath_i.regfile_i.iy",
        "SP"   : "z80_i.cpu_i.datapath_i.reg_sp_i.q",
        "PC"   : "z80_i.cpu_i.datapath_i.reg_pc_i.q",
        "DMEM" : "z80_i.memory_control_i.datamem_mock_i.datamem",
        "SWP"  : "z80_i.memory_control_i.datamem_mock_i.datamem_swp"
    }

    VUNIT_STATE_FMT = {
        "A"    : "{0} = 8'h{1:02X};\n",
        "A'"   : "{0} = 8'h{1:02X};\n",
        "F"    : "{0} = 8'h{1:02X};\n",
        "F'"   : "{0} = 8'h{1:02X};\n",
        "BC"   : "{0} = 16'h{1:04X};\n",
        "B'C'" : "{0} = 16'h{1:04X};\n",
        "DE"   : "{0} = 16'h{1:04X};\n",
        "D'E'" : "{0} = 16'h{1:04X};\n",
        "HL"   : "{0} = 16'h{1:04X};\n",
        "H'L'" : "{0} = 16'h{1:04X};\n",
        "IX"   : "{0} = 16'h{1:04X};\n",
        "IY"   : "{0} = 16'h{1:04X};\n",
        "PC"   : "{0} = 16'h{1:04X};\n",
        "SP"   : "{0} = 16'h{1:04X};\n"
    }

    VUNIT_EXPECT_FMT = {
        "A"    : "unit.assert_eq8(8'h{0:02X}, {1},\n\"A ({2})\");\n",
        "A'"   : "unit.assert_eq8(8'h{0:02X}, {1},\n\"A' ({2})\");\n",
        "S"    : "unit.assert_eq(1'b{0}, {1},\n\"S ({2})\");\n",
        "S'"   : "unit.assert_eq(1'b{0}, {1},\n\"S' ({2})\");\n",
        "Z"    : "unit.assert_eq(1'b{0}, {1},\n\"Z ({2})\");\n",
        "Z'"   : "unit.assert_eq(1'b{0}, {1},\n\"Z' ({2})\");\n",
        "H"    : "unit.assert_eq(1'b{0}, {1},\n\"H ({2})\");\n",
        "H'"   : "unit.assert_eq(1'b{0}, {1},\n\"H' ({2})\");\n",
        "PV"   : "unit.assert_eq(1'b{0}, {1},\n\"PV ({2})\");\n",
        "PV'"  : "unit.assert_eq(1'b{0}, {1},\n\"PV' ({2})\");\n",
        "N"    : "unit.assert_eq(1'b{0}, {1},\n\"N ({2})\");\n",
        "N'"   : "unit.assert_eq(1'b{0}, {1},\n\"N' ({2})\");\n",
        "C"    : "unit.assert_eq(1'b{0}, {1},\n\"C ({2})\");\n",
        "C'"   : "unit.assert_eq(1'b{0}, {1},\n\"C' ({2})\");\n",
        "BC"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"BC ({2})\");\n",
        "B'C'" : "unit.assert_eq16(16'h{0:04X}, {1},\n\"B'C' ({2})\");\n",
        "DE"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"DE ({2})\");\n",
        "D'E'" : "unit.assert_eq16(16'h{0:04X}, {1},\n\"D'E' ({2})\");\n",
        "HL"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"HL ({2})\");\n",
        "H'L'" : "unit.assert_eq16(16'h{0:04X}, {1},\n\"H'L' ({2})\");\n",
        "IX"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"IX ({2})\");\n",
        "IY"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"IY ({2})\");\n",
        "SP"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"SP ({2})\");\n",
        "PC"   : "unit.assert_eq16(16'h{0:04X}, {1},\n\"PC ({2})\");\n",
        "DMEM" : "unit.assert_eq8(8'h{0:02X}, {1}[13'h{2:04X}],\n\"DMEM ({3})\");\n",
        "SWP"  : "{0}[16'h{1:04X}] =\n{2}[16'h{3:04X}];\n",
    }

    VUNIT_FLAG_ORDER = ['S', 'Z', 'H', 'PV', 'N', 'C']

    global current_pc

    flagignore = options['flagignore']
    memcheck = options['memcheck']
    pccheck = options['pccheck']

    # z80sim input
    init_asm = ['START:\n']
    init_flags = '0x00'
    init_flags_p = '0x00'

    test_ops = []

    # ncsim input
    test_heading_fmt = "// BEGIN TESTCASE #{0}\n"
    test_heading = test_heading_fmt.format(test_no)

    test = [test_heading]
    progmem = [test_heading]

    offs = 0
    for state in state_vector.states:
        width = STATE_WIDTHS[state]
        binstr = ''.join(map(str, state_vector.bitvector[offs:(offs + width)]))
        binvalue = int(binstr, 2)

        if state.startswith('INST'):
            test_ops.append(chr(binvalue))
            progmem.append('{0:02X}\n'.format(binvalue))
        else:
            vunit_state_fmt = VUNIT_STATE_FMT[state]
            vunit_state = vunit_state_fmt.format(VUNIT_ELEMS[state], binvalue)
            test.append(vunit_state)

            if state == 'F':
                init_flags = '{0:02X}'.format(binvalue)
            elif state == "F'":
                init_flags_p = '{0:02X}'.format(binvalue)
            else:
                init_asm.append(ASM_STATE_FMT[state].format(binvalue))

        if memcheck and state in memcheck.pre:
            memcheck.pre[state] = binvalue

        offs += width

    # create reference simulation output
    asm_tmp = open(ASM_FILE, 'w+')
    bin_tmp = open(PROGMEM_BIN_FILE, 'w+')
    devnull = open(os.devnull, 'w')

    try:
        # assemble bytecode
        asm_tmp.writelines(init_asm)
        asm_tmp.close()

        z80asm = subprocess.Popen([ASM, ASM_FILE], stdout=devnull)
        z80asm.wait()

        # inject instruction bytes
        data = bin_tmp.read()
        instructions = [data[i:i+1] for i in range(len(data))]

        for op in test_ops:
            instructions.append(op)

        bin_tmp.seek(0)
        bin_tmp.write(b''.join(instructions))
        bin_tmp.close()

        # get breakpoint
        brk = DATAMEM_SIZE + len(instructions) - len(test_ops) - 3

        args = [
            RUNSIM,
            PROGMEM_BIN_FILE,
            '{0:04X}'.format(PROGMEM_SIZE),
            DATAMEM_BIN_FILE,
            '{0:04X}'.format(DATAMEM_SIZE),
            init_flags,
            init_flags_p,
            '{0:04X}'.format(brk)
        ]

        if memcheck:
            for state in memcheck.states:
                components = MemCheck.MNEMONICS[state]
                operator, operands = components[0], components[1:]

                if operator == 'id':
                    addr = memcheck.pre[operands[0]]
                elif operator == '+':
                    addr = sum([memcheck.pre[op] for op in operands])
                else:
                    err = "unrecognized memcheck operator: {0}"
                    raise ValueError(err.format(operator))

                memcheck.addrs.append(addr)

            args += ['{0:04x}'.format(a) for a in memcheck.addrs]

        z80sim = subprocess.Popen(args, stdout=subprocess.PIPE)
        z80sim.wait()

    finally:
        asm_tmp.close()
        bin_tmp.close()
        devnull.close()

        os.remove(ASM_FILE)
        os.remove(PROGMEM_BIN_FILE)

    # parse simulation results
    simout = z80sim.stdout.read()

    m = re.search(r'Software breakpoint.*\s+(.*)\n(.*)\n>>>', simout)
    if not m:
        err = "an error occured during simulation, check for illegal opcodes"
        raise ValueError(err)

    # obtain expected register values
    regs, values = m.groups()
    regs = [r.strip() for r in regs.split()]
    values = [v.strip() for v in values.split()]

    reg_expected = {}
    flag_expected = {}
    pc_expected = None
    for r, v in zip(regs, values):
        if r == 'SZHPNC':
            flags = [int(b, 2) for b in v]
            if not flagignore & 0x80:
                flag_expected['S'] = flags[0]
            if not flagignore & 0x40:
                flag_expected['Z'] = flags[1]
            if not flagignore & 0x10:
                flag_expected['H'] = flags[2]
            if not flagignore & 0x04:
                flag_expected['PV'] = flags[3]
            if not flagignore & 0x02:
                flag_expected['N'] = flags[4]
            if not flagignore & 0x01:
                flag_expected['C'] = flags[5]

        elif r == "A'F'":
            reg_expected["A'"] = int(v[:2], 16)

            flags = [int(b, 2) for b in '{0:08b}'.format(int(v[2:], 16))]
            if not flagignore & 0x80:
                flag_expected["S'"] = flags[0]
            if not flagignore & 0x40:
                flag_expected["Z'"] = flags[1]
            if not flagignore & 0x10:
                flag_expected["H'"] = flags[3]
            if not flagignore & 0x04:
                flag_expected["PV'"] = flags[5]
            if not flagignore & 0x02:
                flag_expected["N'"] = flags[6]
            if not flagignore & 0x01:
                flag_expected["C'"] = flags[7]

        elif r == 'PC' and pccheck != 'none':
            pc_expected = int(v, 16)

            if pc_expected == DATAMEM_SIZE + len(test_ops):
                pc_expected = current_pc + len(test_ops)
            elif pccheck == 'rel':
                pc_expected = (pc_expected - DATAMEM_SIZE + current_pc) % (2**16)

            current_pc += len(test_ops)

        elif r in state_vector.states:
            reg_expected[r] = int(v, 16)

    # optain expected memory locations
    if memcheck:
        for addr in memcheck.addrs:
            addr_hex = '{0:04X}'.format(addr)
            addr_lsn = int(addr_hex[3], 16)

            simout = simout[m.end():]
            m = re.search(r'Adr.*\n[0-9a-f]{4} - (.*)\t', simout)

            mem_row = [int(val, 16) for val in m.group(1).split()]
            memcheck.expected.append(mem_row[addr_lsn])

    # add timeout loop to testbench code
    waitloop = [
        "#(CLKPERIOD);",
        "",
        "loop_counter = 5'b0;",
        "while (z80_i.cpu_i.controller_i.fsm_i.state != FSM_STATE_INSTR_FETCH1_1)",
        "begin",
        "    #(CLKPERIOD);",
        "    loop_counter = loop_counter + 1;",
        "    if (loop_counter == 5'b11111)",
        "        unit.fail(\"Instruction not terminating\");",
        "end"
    ]

    test.append('\n{0}\n\n'.format('\n'.join(waitloop)))

    # add register assertions to testbench code
    for state in state_vector.states:
        if state in ['INST1', 'INST2', 'INST3', 'INST4', 'F', "F'", "DUMMY"]:
            continue

        fmt = VUNIT_EXPECT_FMT[state]
        msg = "Testcase #{0} {1}".format(test_no, uuid.uuid4())
        expect = fmt.format(reg_expected[state], VUNIT_ELEMS[state], msg)

        test.append(expect)

    for flag in VUNIT_FLAG_ORDER:
        if flag not in flag_expected:
            continue

        fmt = VUNIT_EXPECT_FMT[flag]
        msg = "Testcase #{0} {1}".format(test_no, uuid.uuid4())
        expect = fmt.format(flag_expected[flag], VUNIT_ELEMS[flag], msg)

        test.append(expect)

    # add memory assertions to testbench code
    if memcheck:
        test.append('\n')

        for addr, exp in zip(memcheck.addrs, memcheck.expected):
            fmt = VUNIT_EXPECT_FMT['DMEM']
            msg = "Testcase #{0} {1}".format(test_no, uuid.uuid4())
            expect = fmt.format(exp, VUNIT_ELEMS['DMEM'], addr, msg)

            test.append(expect)

        for addr in memcheck.addrs:
            fmt = VUNIT_EXPECT_FMT['SWP']
            swp = fmt.format(VUNIT_ELEMS['DMEM'], addr,
                             VUNIT_ELEMS['SWP'], addr)

            test.append(swp)

    # add program counter assertion to testbench code
    if pccheck != 'none':
        test.append('\n')

        fmt = VUNIT_EXPECT_FMT['PC']
        msg = "Testcase #{0} {1}".format(test_no, uuid.uuid4())
        test.append(fmt.format(pc_expected, VUNIT_ELEMS['PC'], msg))

        fmt = VUNIT_STATE_FMT['PC']
        test.append(fmt.format(VUNIT_ELEMS['PC'], current_pc))

    test.append('\n')

    return test, progmem


if __name__ == '__main__':
    # read test description
    with open(ZEX_FILE) as infile:
        zex = infile.read()

    # strip comments and trailing whitespace
    zex = re.sub(r'(?m)\s*(#.*)?$', '', zex)

    # remove empty lines
    zex = '\n'.join([line for line in zex.split('\n') if line])

    options = {
        'name' : None,
        'desc' : None,
        'base' : None,
        'cycle' : None,
        'skip' : None,
        'repeat' : 0,
        'memcheck' : None,
        'pccheck' : 'none',
        'flagignore' : 0x00
    }

    seen_options = set()
    for i, line in enumerate(zex.split('\n')):
        m = re.match('^(\w+):\s*(.*)$', line)
        if not m:
            raise ValueError("syntax error in line {0} of zex file".format(i))

        option, value = m.groups()
        if option not in options:
            raise ValueError("unknown option: '{0}'".format(option))
        if option in seen_options:
            raise ValueError("duplicate option: '{0}'".format(option))

        def parse_flagignore(fmt):
            m = re.match('([0-9a-fA-F]{2})h', fmt)
            if not m:
                raise ValueError("invalid flagignore mask: '{0}'".format(fmt))

            return int(m.group(1), 16)

        def parse_pccheck(fmt):
            if fmt not in ['none', 'abs', 'rel']:
                raise ValueError("invalid pccheck value")

            return fmt

        parse = {
            'base'       : StateVector.parse,
            'cycle'      : StateVector.parse,
            'skip'       : SkipVector.parse,
            'repeat'     : int,
            'memcheck'   : MemCheck.parse,
            'pccheck'    : parse_pccheck,
            'flagignore' : parse_flagignore
        }.get(option, str)

        options[option] = parse(value)
        seen_options.add(option)

    mandatory_options = ['name', 'desc', 'base']
    for option in mandatory_options:
        if options[option] is None:
            raise ValueError("missing mandatory option {0}", option)

    # state vector cycle positions
    cycle_pos = [i for i, b in enumerate(options['cycle'].bitvector) if b == 1]
    cycles = list(range(2**len(cycle_pos)))

    if (len(cycles) > MAXTESTS):
        err = "trying to generate {0} tests (maximum is {1})"
        raise ValueError(err.format(len(cycles), MAXTESTS))

    # generate testcase files
    testcase_out = open(TESTCASE_FILE, 'w+')
    progmem_out = open(PROGMEM_FILE, 'w+')
    datamem_out = open(DATAMEM_FILE, 'w+')
    datamem_bin_out = open(DATAMEM_BIN_FILE, 'w+')

    # create random data memory
    datamem = []
    datamem_bin = [255, 0, 0]
    for addr in range(DATAMEM_SIZE):
        rand_val = random.randint(0, 255)

        datamem.append('@{0:04X} {1:02X}\n'.format(addr, rand_val))
        datamem_bin.append(rand_val)

    datamem_bin = bytes(bytearray(datamem_bin))

    try:
        # fill data memory
        datamem_out.writelines(datamem)
        datamem_out.close()

        datamem_bin_out.write(datamem_bin)
        datamem_bin_out.close()

        # begin creating testcase file
        testcase_out.write('unit.start("{0} ({1})");\n\n'.format(
            options['name'], options['desc']))

        repetitions = options['repeat'] + 1
        tests_total = len(cycles) * repetitions

        test_no = 0
        for cycle in cycles:
            for _ in range(repetitions):
                # display progress
                if options['skip']:
                    progress = "\rGenerating test {0}".format(test_no + 1)
                else:
                    progress = "\rGenerating test {0}/{1}".format(test_no + 1,
                                                                  tests_total)
                sys.stdout.write(progress)
                sys.stdout.flush()

                # create state vector variant
                vect = options['base'].copy()

                if cycle > 0:
                    setbits = '{0:b}'.format(cycle).zfill(len(cycle_pos))
                    for i, b in enumerate(setbits):
                        vect.bitvector[cycle_pos[i - 1]] = int(b)

                vect.randomize()

                # potentially skip specific state vectors
                if options['skip'] and options['skip'].check(vect):
                    continue

                # reset any memory checks
                if options['memcheck']:
                    options['memcheck'].clear()

                # generate test and update files
                test, progmem = generate_test(test_no, vect, options)

                testcase_out.writelines(test)
                progmem_out.writelines(progmem)

                test_no += 1

        testcase_out.write('unit.finish("{0} ({1})");\n'.format(
            options['name'], options['desc']))

        sys.stdout.write('\n')

    finally:
        testcase_out.close()
        progmem_out.close()
        datamem_out.close()
        datamem_bin_out.close()

        os.remove(DATAMEM_BIN_FILE)
